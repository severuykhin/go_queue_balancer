package main

import (
	"fmt"
	"os"

	"github.com/nats-io/nats.go"
)

func main() {

	signals := make(chan os.Signal, 1)

	nc, _ := nats.Connect(nats.DefaultURL)
	js, _ := nc.JetStream(nats.PublishAsyncMaxPending(256))

	// Простой асинхронный эфемерный консьюмер
	// До сих пор все потребители, которых вы видели, были Durable,
	// то есть они существуют даже после того, как вы отключитесь от Jetstream.
	// Эфемерный потребитель существует до тех пор, пока активна любая подписка на subject его доставки.
	// Он автоматически удаляется после короткого периода отсрочки для обработки перезапусков при отсутствии подписчиков.
	// эфемерные консьюмеры могут быть только push based
	//
	// в консьюмере может быть задан режим подтвеждения сообщения - AckPolicy
	// AckExplicit - подтверждение или неподтверждение для всех входящих сообщениz
	js.QueueSubscribe("SOME_STREAM.group_1", "test_2", func(m *nats.Msg) {
		fmt.Printf("Received a JetStream message: %s\n", string(m.Data))
		// m.Ack()
		// Если использовать Nak - сообщение передоавится в стрим

		// Nak - передобавялет сообщение в стрим. Проблема в том, что передобавление нагружает процессор
		// При передобавлении по кругу 5 сообщений - потреблени cpu контейнера master ноды кластера выросло до 60%
		// есть AckWait - но это не совсем то, что нам нужно. Это лимит обработки одного сообщщения по времен
		// Если в течение этого лимита сообщение не будет подтверждено, оно передобавится о стрим
		// m.Nak()
		// time.Sleep(time.Second * 2)
		m.Ack()
	}, nats.AckExplicit())

	// То есть эфемерный консьюмер лучше всего подходит для следующих целей
	// - Поток технических событий, которые нужно обработать все 100%
	// - Очень было бы удобно при старте приложения и чтения всего потока и распределения по сообществам
	//   Но тогда в таком случае необходиом передобавлять сообщение в стрим
	//   Стратегия с простым "неподтверждением" не подойдет? Потому что хранение сообщения задается на уровне retention

	<-signals

}
